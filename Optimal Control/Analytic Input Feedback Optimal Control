import numpy as np 
import sympy as sp
import scipy
import matplotlib.pyplot as plt

x, u, n, rho = sp.symbols('x u n rho', real = True) #x = state, u = input
locals_map = {
    "x": x, 
    "u": u, 
    "n": n, 
    "rho": rho,
    "sin": sp.sin, 
    
    "cos": sp.cos, 
    "tan": sp.tan,
    "exp": sp.exp, 
    "log": sp.log, 
    "sqrt": sp.sqrt,
    "Abs": sp.Abs
}
def minimization(H_expression, u):
    dH_du = sp.diff(H_expression, u)
    solutions = sp.Eq(dH_du, 0)
    
    candidate_controls = sp.solve(solutions, u)
    
    d2H_du2 = sp.diff(H_expression, u, 2)
    return {"dH_du": dH_du, "solutions": solutions, "candidate_controls": candidate_controls, "d2H_du2":d2H_du2}
def read_user_inputs(prompt: str) -> sp.Expr:
    parser = input(prompt + " = ").strip()
    expression = sp.sympify(parser, locals=locals_map)
    return sp.simplify(expression)
def hjb_residual(running_cost, f, dV_dx, value_function, horizon_type, rho=None):
    H = sp.simplify(running_cost + dV_dx * f)
    minimizer = minimization(H, u)

    if not minimizer["candidate_controls"]:
        return None, "No closed-form u*"

    u_star = minimizer["candidate_controls"][0]
    H_star = sp.simplify(H.subs(u, u_star))

    if horizon_type == "infinite":
        return sp.simplify(H_star - rho * value_function), "infinite"
    else:
        return H_star, "finite"
if __name__ == "__main__": 
    print("Enter the following expressions -")
    #Expressions (user defined)
    print("f(x,u)")
    print("Final Cost - N(x,n) -")
    print("Running Cost - l(x,u) -")
    print("Value Function - V(x) - ")

    #Horizon Type
    print("Select horizon type:")
    print("  1 : Infinite horizon (stationary HJB)")
    print("  2 : Finite horizon")

    choice = input("Enter 1 or 2: ").strip()

    if choice == "1":
        horizon_type = "infinite"
    elif choice == "2":
        horizon_type = "finite"
    else:
        raise ValueError("Invalid choice. Enter 1 or 2.")

    #Read Inputs
    f = read_user_inputs("f(x,u)")
    running_cost = read_user_inputs("Running Cost - l(x,u) -")
    final_cost = read_user_inputs("Final Cost - N(x,n) -")
    value_function = read_user_inputs("Value Function - V(x) -")
    dV_dx = sp.diff(value_function, x)
    H = sp.simplify(running_cost + dV_dx*f) # Hamiltonian
    minimizer = minimization(H, u)



    print("\n--- SYMBOLIC RESULTS ---")
    print("f(x,u) =", f)
    print("l(x,u) =", running_cost)
    print("N(x,n) =", final_cost, "  (boundary condition; not used in stationary min step)")
    print("V(x)   =", value_function)
    print("dV/dx  =", dV_dx)
    print("H(x,u) =", H)
    print("FOC dH/du = 0:", minimizer["solutions"])
    print("u* candidates:", minimizer["candidate_controls"])
    print("d2H/du2:", minimizer["d2H_du2"])

    if not minimizer["candidate_controls"]:
        print("\nNo closed-form u*(x) found. Try a cost convex in u (often quadratic) and simpler dynamics in u.")
        raise SystemExit

    # pick first candidate
    u_star = sp.simplify(minimizer["candidate_controls"][0])
    H_star = sp.simplify(H.subs(u, u_star))

    print("\nChosen u*(x) =", u_star)
    print("Reduced H*(x)=H(x,u*(x)) =", H_star)

    #HJB residual (useful for infinite horizon cases)
    if horizon_type == "infinite":
        # here "rho" is the SYMBOL, for the residual expression
        residual_expr, _ = hjb_residual(running_cost, f, dV_dx, value_function, horizon_type, rho=rho)
        print("\nHJB residual (symbolic): H*(x) - rho*V(x) =")
        print(residual_expr)
    else:
        print("\nFinite horizon selected:")
        print("Terminal condition would be V(x,T) = N(x,n). (Time-dependent V(x,t) not implemented here.)")

    #numeric parametes
    def read_float(name, default):
        s = input(f"Numeric value for {name} (default {default}): ").strip()
        return float(s) if s else float(default)

    n_val = read_float("n", 1.0)
    rho_val = read_float("rho", 0.0)

    param_subs = {n: n_val, rho: rho_val}
    u_star_num = sp.lambdify(x, sp.simplify(u_star.subs(param_subs)), "numpy")
    H_star_num = sp.lambdify(x, sp.simplify(H_star.subs(param_subs)), "numpy")

    # Optional: contour plot of H(x,u)
    H_num = sp.lambdify((x, u), sp.simplify(H.subs(param_subs)), "numpy")

    # x-range
    x_min = read_float("x_min", -5.0)
    x_max = read_float("x_max", 5.0)
    num_points = int(read_float("num_points", 400))

    x_grid = np.linspace(x_min, x_max, num_points)
    u_vals = u_star_num(x_grid)
    H_vals = H_star_num(x_grid)

    print("\n--- RAW NUMERIC SAMPLES (first 10) ---")
    print("x:", x_grid[:10])
    print("u*(x):", u_vals[:10])
    print("H*(x):", H_vals[:10])

    # ---------- plots ----------
    plt.figure()
    plt.plot(x_grid, u_vals)
    plt.xlabel("x")
    plt.ylabel("u*(x)")
    plt.title(f"Optimal control candidate u*(x) â€” {horizon_type} horizon")
    plt.grid(True)

    plt.figure()
    plt.plot(x_grid, H_vals)
    plt.xlabel("x")
    plt.ylabel("H*(x)")
    plt.title("Reduced Hamiltonian H*(x) = H(x, u*(x))")
    plt.grid(True)

    # Contour plot with u*(x) overlay
    finite_mask = np.isfinite(u_vals)
    if np.any(finite_mask):
        umin = np.min(u_vals[finite_mask])
        umax = np.max(u_vals[finite_mask])
    else:
        umin, umax = -2.0, 2.0

    pad = 2.0
    u_grid = np.linspace(umin - pad, umax + pad, 250)
    X, U = np.meshgrid(x_grid, u_grid)
    Z = H_num(X, U)

    plt.figure()
    cs = plt.contourf(X, U, Z, levels=40)
    plt.colorbar(cs)
    plt.plot(x_grid, u_vals, linewidth=2)
    plt.xlabel("x")
    plt.ylabel("u")
    plt.title("H(x,u) contour with u*(x) overlay")

    plt.show()
